#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_GOOGLE_include_directive : enable

#include "ray_common.glsl"

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, set = 0, rgba8) uniform image2D image;
layout(binding = 2, set = 0) uniform CameraProperties
{
    mat4 viewInverse;
    mat4 projInverse;
} cam;

layout(push_constant) uniform PushConstants
{
    push_constants_t push_constants;
};

layout(location = 0) rayPayloadEXT hit_record_t hit_record;

vec3 trace(vec2 coord, vec2 size)
{
    // State of the random number generator.
    uint rngState = uint(push_constants.batch_index + push_constants.time * (size.x * coord.y + coord.x));

    vec3 camera_position = (cam.viewInverse * vec4(0, 0, 0, 1)).xyz;

    // The sum of the colors of all of the samples.
    vec3 sample_sum = vec3(0.0);

    // Limit the kernel to trace at most 64 samples.
    const int NUM_SAMPLES = 8;

    float sample_offset = rng_float(rngState);

    // sample random dirctions around the pixel's center
    //           1
    //    .------+------.
    //    |      |      |
    // -a + ---- 0 ---- + a
    //    |      |      |
    //    '------+------'
    //          -1
    for (int sampleIdx = 0; sampleIdx < NUM_SAMPLES; sampleIdx++)
    {
//        const vec2 randomPixelCenter = coord + vec2(rng_float(rngState), rng_float(rngState));

        // random+stratified sampling
        const vec2 randomPixelCenter = coord + fract(Hammersley(sampleIdx, NUM_SAMPLES) + vec2(sample_offset));
        const vec2 inUV = randomPixelCenter / size;
        vec2 d = inUV * 2.0 - 1.0;

        // ray direction:
        vec3 origin = camera_position;
        vec3 target = (cam.projInverse * vec4(d.x, d.y, 1, 1)).xyz;
        vec3 direction = (cam.viewInverse * vec4(normalize(target.xyz), 0)).xyz;

        float tmin = 0.0001;
        float tmax = 10000.0;

        const uint max_num_bounces = 8;

        // models light absorbtion through materials
        vec3 accumulated_color = vec3(1);

        for (int i = 0; i < max_num_bounces; i++)
        {
            hit_record.intersection = false;

            // trace one ray
            traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, origin, tmin, direction, tmax, 0);

            // light absorbtion
            accumulated_color *= hit_record.color;

            // nothing hit, end recursion
            if (!hit_record.intersection)
            {
                // sum colors for all samples
                sample_sum += accumulated_color;

                break;
            }

            // flip the normal so it points against the ray direction:
            hit_record.normal = faceforward(hit_record.normal, direction, hit_record.normal);

            // offset position it slightly along the normal
            origin = hit_record.position + 0.0001 * hit_record.normal;

            // scatter ray direction
            direction = rng_lambert(hit_record.normal, rngState);
//            vec2 Xi = fract(Hammersley(i, max_num_bounces) + vec2(rng_float(rngState)));
//            direction = ImportanceSampleCosine(Xi, hit_record.normal);
        }
    }
    return sample_sum / NUM_SAMPLES;
}

void main()
{
    vec3 color = trace(gl_LaunchIDEXT.xy, gl_LaunchSizeEXT.xy);

    if(push_constants.batch_index != 0)
    {
        uint size = push_constants.batch_index;

        color = (size * imageLoad(image, ivec2(gl_LaunchIDEXT.xy)).rgb + color) / (size + 1);
    }

    imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(color, 1.0));
}
