#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_GOOGLE_include_directive : enable

#include "ray_common.glsl"

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, set = 0, rgba8) uniform image2D image;
layout(binding = 2, set = 0) uniform CameraProperties
{
    mat4 viewInverse;
    mat4 projInverse;
} cam;

layout(push_constant) uniform PushConstants
{
    push_constants_t push_constants;
};

layout(location = 0) rayPayloadEXT hit_record_t hit_record;

// Schlick's fresnel approximation
vec3 F_schlick(vec3 f0, float u)
{
    return f0 + (vec3(1.0) - f0) * pow(1.0 - u, 5.0);
}

vec3 trace(vec2 coord, vec2 size)
{
    // State of the random number generator.
    uint rngState = uint(push_constants.batch_index + push_constants.time * (size.x * coord.y + coord.x));

    vec3 camera_position = (cam.viewInverse * vec4(0, 0, 0, 1)).xyz;

    // The sum of the colors of all of the samples.
    vec3 sample_sum = vec3(0.0);

    // Limit the kernel to trace at most 64 samples.
    const int NUM_SAMPLES = 8;

    float sample_offset = rng_float(rngState);

    // sample random dirctions around the pixel's center
    //           1
    //    .------+------.
    //    |      |      |
    // -a + ---- 0 ---- + a
    //    |      |      |
    //    '------+------'
    //          -1
    for (int sampleIdx = 0; sampleIdx < NUM_SAMPLES; sampleIdx++)
    {
        // random+stratified sampling
        const vec2 randomPixelCenter = coord + fract(Hammersley(sampleIdx, NUM_SAMPLES) + vec2(sample_offset));
        const vec2 inUV = randomPixelCenter / size;
        vec2 d = inUV * 2.0 - 1.0;

        // ray direction:
        vec3 origin = camera_position;
        vec3 target = (cam.projInverse * vec4(d.x, d.y, 1, 1)).xyz;
        vec3 direction = (cam.viewInverse * vec4(normalize(target.xyz), 0)).xyz;

        float tmin = 0;
        float tmax = 10000.0;

        const uint max_num_bounces = 4;

        // models light absorbtion through materials
        vec3 accumulated_color = vec3(1);

        for (int i = 0; i < max_num_bounces; i++)
        {
            hit_record.intersection = false;
            hit_record.metalness = 0.0;

            // trace one ray
            traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, origin, tmin, direction, tmax, 0);
        
            // light absorbtion
            accumulated_color *= hit_record.intersection ? hit_record.color : mix(hit_record.color, vec3(0.04), hit_record.metalness);

            // nothing hit, end recursion
            if (!hit_record.intersection)
            {
                // sum colors for all samples
                sample_sum += accumulated_color;

                break;
            }

            // flip the normal so it points against the ray direction:
            hit_record.normal = faceforward(hit_record.normal, direction, hit_record.normal);

            // offset position along the normal
            origin = hit_record.position + 0.0001 * hit_record.normal;

            // scatter ray direction
            vec2 Xi = vec2(rng_float(rngState), rng_float(rngState));

            // diffuse reflection
            vec3 reflect_dir_cosine = ImportanceSampleCosine(Xi, hit_record.normal);

            // no diffuse rays for metal
            float prob = rng_float(rngState) * (1.0 - hit_record.metalness) < 0.5 ? 1.0 : 0.0;

            // possible half-vector from GGX distribution
            vec3 H = ImportanceSampleGGX(Xi, hit_record.roughness, hit_record.normal);
            vec3 reflect_dir_ggx = reflect(direction, H);

            direction = mix(reflect_dir_cosine, reflect_dir_ggx, prob);

            float NoL = max(dot(hit_record.normal, direction), 0.0);
            if (NoL <= 0.0){ break; }
        }
    }
    return sample_sum / NUM_SAMPLES;
}

void main()
{
    vec3 color = trace(gl_LaunchIDEXT.xy, gl_LaunchSizeEXT.xy);

    if (push_constants.batch_index != 0)
    {
        uint size = push_constants.batch_index;
        //        size = min(size, 10);
        color = (size * imageLoad(image, ivec2(gl_LaunchIDEXT.xy)).rgb + color) / (size + 1);
    }

    imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(color, 1.0));
}
